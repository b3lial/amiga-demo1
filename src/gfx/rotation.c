// Copyright 2021 Christian Ammann

#include <exec/types.h>
#include <exec/memory.h>
#include <clib/exec_protos.h>

#include "rotation.h"
#include "../utils/utils.h"

struct RotationEngineContext {
    UBYTE *srcBuffer;
    UBYTE *destBuffer[DEST_BUFFER_SIZE];
    UBYTE rotationSteps;
    UWORD bitmapWidth;
    UWORD bitmapHeight;
    WORD halfBitmapHeight;
    WORD halfBitmapWidth;
    WORD *y_mult_sin;
    WORD *y_mult_cos;
    WORD *x_mult_sin;
    WORD *x_mult_cos;
};

static struct RotationEngineContext ctx = {
    .srcBuffer = NULL,
    .destBuffer = {NULL},
    .rotationSteps = 0,
    .bitmapWidth = 0,
    .bitmapHeight = 0,
    .halfBitmapHeight = 0,
    .halfBitmapWidth = 0,
    .y_mult_sin = NULL,
    .y_mult_cos = NULL,
    .x_mult_sin = NULL,
    .x_mult_cos = NULL
};

// cosinus lookup table in fix point format
// generated by lookup_cos.py
WORD cosLookup[] = {
    FLOATTOFIX(1.0),
    FLOATTOFIX(0.9848),
    FLOATTOFIX(0.9397),
    FLOATTOFIX(0.866),
    FLOATTOFIX(0.766),
    FLOATTOFIX(0.6428),
    FLOATTOFIX(0.5),
    FLOATTOFIX(0.342),
    FLOATTOFIX(0.1736),
    FLOATTOFIX(0.0),
    FLOATTOFIX(-0.1736),
    FLOATTOFIX(-0.342),
    FLOATTOFIX(-0.5),
    FLOATTOFIX(-0.6428),
    FLOATTOFIX(-0.766),
    FLOATTOFIX(-0.866),
    FLOATTOFIX(-0.9397),
    FLOATTOFIX(-0.9848),
    FLOATTOFIX(-1.0),
    FLOATTOFIX(-0.9848),
    FLOATTOFIX(-0.9397),
    FLOATTOFIX(-0.866),
    FLOATTOFIX(-0.766),
    FLOATTOFIX(-0.6428),
    FLOATTOFIX(-0.5),
    FLOATTOFIX(-0.342),
    FLOATTOFIX(-0.1736),
    FLOATTOFIX(-0.0),
    FLOATTOFIX(0.1736),
    FLOATTOFIX(0.342),
    FLOATTOFIX(0.5),
    FLOATTOFIX(0.6428),
    FLOATTOFIX(0.766),
    FLOATTOFIX(0.866),
    FLOATTOFIX(0.9397),
    FLOATTOFIX(0.9848)};

// sinus lookup table in fix point format
// generated by lookup_sin.py
WORD sinLookup[] = {
    FLOATTOFIX(0.0),
    FLOATTOFIX(0.1736),
    FLOATTOFIX(0.342),
    FLOATTOFIX(0.5),
    FLOATTOFIX(0.6428),
    FLOATTOFIX(0.766),
    FLOATTOFIX(0.866),
    FLOATTOFIX(0.9397),
    FLOATTOFIX(0.9848),
    FLOATTOFIX(1.0),
    FLOATTOFIX(0.9848),
    FLOATTOFIX(0.9397),
    FLOATTOFIX(0.866),
    FLOATTOFIX(0.766),
    FLOATTOFIX(0.6428),
    FLOATTOFIX(0.5),
    FLOATTOFIX(0.342),
    FLOATTOFIX(0.1736),
    FLOATTOFIX(0.0),
    FLOATTOFIX(-0.1736),
    FLOATTOFIX(-0.342),
    FLOATTOFIX(-0.5),
    FLOATTOFIX(-0.6428),
    FLOATTOFIX(-0.766),
    FLOATTOFIX(-0.866),
    FLOATTOFIX(-0.9397),
    FLOATTOFIX(-0.9848),
    FLOATTOFIX(-1.0),
    FLOATTOFIX(-0.9848),
    FLOATTOFIX(-0.9397),
    FLOATTOFIX(-0.866),
    FLOATTOFIX(-0.766),
    FLOATTOFIX(-0.6428),
    FLOATTOFIX(-0.5),
    FLOATTOFIX(-0.342),
    FLOATTOFIX(-0.1736)};

BOOL initRotationEngine(UBYTE rs, USHORT bw, USHORT bh) {
    ctx.rotationSteps = rs;
    ctx.bitmapWidth = bw;
    ctx.bitmapHeight = bh;
    ctx.halfBitmapHeight = ctx.bitmapHeight / 2;
    ctx.halfBitmapWidth = ctx.bitmapWidth / 2;

    if (ctx.bitmapWidth > MAX_BITMAP_WIDTH || ctx.bitmapHeight > MAX_BITMAP_HEIGHT) {
        writeLogFS("Error: Invalid bitmap size %dx%d\n", ctx.bitmapWidth, ctx.bitmapHeight);
        writeLogFS("Maximum bitmap size is %dx%d\n", MAX_BITMAP_WIDTH, MAX_BITMAP_HEIGHT);
        return FALSE;
    }

    ctx.y_mult_sin = AllocVec(sizeof(WORD) * MAX_BITMAP_HEIGHT, MEMF_FAST | MEMF_CLEAR);
    if (!ctx.y_mult_sin) {
        writeLog("Error: Could not allocate memory for y_mult_sin\n");
        return FALSE;
    }

    ctx.y_mult_cos = AllocVec(sizeof(WORD) * MAX_BITMAP_HEIGHT, MEMF_FAST | MEMF_CLEAR);
    if (!ctx.y_mult_cos) {
        writeLog("Error: Could not allocate memory for y_mult_cos\n");
        return FALSE;
    }

    ctx.x_mult_sin = AllocVec(sizeof(WORD) * MAX_BITMAP_WIDTH, MEMF_FAST | MEMF_CLEAR);
    if (!ctx.x_mult_sin) {
        writeLog("Error: Could not allocate memory for x_mult_sin\n");
        return FALSE;
    }

    ctx.x_mult_cos = AllocVec(sizeof(WORD) * MAX_BITMAP_WIDTH, MEMF_FAST | MEMF_CLEAR);
    if (!ctx.x_mult_cos) {
        writeLog("Error: Could not allocate memory for x_mult_cos\n");
        return FALSE;
    }

    return allocateChunkyBuffer();
}

/**
 * Rotate the element in source buffer and store the results
 * in destination buffer array.
 */
void rotateAll() {
    USHORT angle = 0;
    UBYTE i = 0;

    for (i = 0; i < ctx.rotationSteps; i++) {
        rotate(ctx.destBuffer[i], angle);
        angle += (360 / ctx.rotationSteps);  // 360 degrees / number of steps == rotation degree
    }
    return;
}

/**
 * Gets a source chunky buffer, rotates it by degree value
 * in RotationData and writes the result into destination
 * chunky buffer. Rotation is performed via matrix multiplcation
 * in fix point format.
 */
void rotate(UBYTE *dest, USHORT angle) {
    UWORD x, y = 0;
    UWORD src_index, dest_index = 0;
    WORD src_x, src_y = 0;
    UWORD lookupIndex;
    UWORD y_mult_bitmapWidth;

    // in this case, we can simply perform a copy
    if (angle == 360 || angle == 0) {
        CopyMem(ctx.srcBuffer, dest, ctx.bitmapWidth * ctx.bitmapHeight);
        return;
    }

    // negate angle because we have to rotate in the opposite direction
    lookupIndex = (360 - angle) / DEGREE_RESOLUTION;

    // precalculate expensive stuff
    preCalcSinCos(lookupIndex, ctx.x_mult_sin, ctx.x_mult_cos, ctx.y_mult_sin, ctx.y_mult_cos);

    // iterate over destination array
    for (y = 0; y < ctx.bitmapHeight; y++) {
        y_mult_bitmapWidth = y * ctx.bitmapWidth;

        for (x = 0; x < ctx.bitmapWidth; x++) {
            // calculate src x/y coordinates
            src_x = FIXTOINT(ctx.x_mult_cos[x] - ctx.y_mult_sin[y]);
            src_y = -FIXTOINT(ctx.x_mult_sin[x] + ctx.y_mult_cos[y]);

            // convert coordinates back to array indexes
            // so we can move the rotated pixel to its new position
            dest_index = x + y_mult_bitmapWidth;
            src_index = (src_x + ctx.halfBitmapWidth) +
                        ((src_y + ctx.halfBitmapHeight) * ctx.bitmapWidth);

            // verify x outofbounds
            if (src_x < -ctx.halfBitmapWidth || src_x >= ctx.halfBitmapWidth) {
                continue;
            }
            // verify y outofbounds
            if (src_y <= -ctx.halfBitmapHeight || (src_y > ctx.halfBitmapHeight)) {
                continue;
            }
            dest[dest_index] = ctx.srcBuffer[src_index];
        }
    }
}

/**
 * Pre-calculate sin/cos values for x/y coordinates
 * because this math is expensive
 */
void preCalcSinCos(UWORD lookupIndex, WORD *sinLookupX, WORD *cosLookupX,
                   WORD *sinLookupY, WORD *cosLookupY) {
    UWORD x, y = 0;
    WORD dest_x, dest_y = 0;

    for (y = 0; y < ctx.bitmapHeight; y++) {
        dest_y = INTTOFIX(ctx.halfBitmapHeight - y);
        sinLookupY[y] = FIXMULT(dest_y, sinLookup[lookupIndex]);
        cosLookupY[y] = FIXMULT(dest_y, cosLookup[lookupIndex]);

        for (x = 0; x < ctx.bitmapWidth; x++) {
            dest_x = INTTOFIX(x - ctx.halfBitmapWidth);
            sinLookupX[x] = FIXMULT(dest_x, sinLookup[lookupIndex]);
            cosLookupX[x] = FIXMULT(dest_x, cosLookup[lookupIndex]);
        }
    }
    return;
}

/**
 * Allocate:
 * - source chunky buffer: contains the object we want to rotate
 * - destination chunky buffer array: contain the rotated objects
 */
BOOL allocateChunkyBuffer(void) {
    BYTE i = 0;

    if (ctx.rotationSteps == 0 || ctx.rotationSteps > DEST_BUFFER_SIZE) {
        writeLogFS("Error: Invalid destination buffer size %d\n", ctx.rotationSteps);
        goto _exit_chunky_source_allocation_error;
    }

    // allocate memory for chunky buffer
    ctx.srcBuffer = AllocVec(ctx.bitmapWidth * ctx.bitmapHeight, MEMF_FAST | MEMF_CLEAR);
    if (!ctx.srcBuffer) {
        writeLog("Error: Could not allocate memory for source chunky buffer\n");
        goto _exit_chunky_source_allocation_error;
    }

    for (i = 0; i < ctx.rotationSteps; i++) {
        ctx.destBuffer[i] = AllocVec(ctx.bitmapWidth * ctx.bitmapHeight, MEMF_FAST | MEMF_CLEAR);
        if (!(ctx.destBuffer[i])) {
            writeLog("Error: Could not allocate memory for destination chunky buffer array\n");
            goto _exit_chunky_source_allocation_rollback;
        }
    }

    return TRUE;

_exit_chunky_source_allocation_rollback:
    FreeVec(ctx.srcBuffer);
    ctx.srcBuffer = NULL;

    for (i -= 1; i >= 0; i--) {
        FreeVec(ctx.destBuffer[i]);
        ctx.destBuffer[i] = NULL;
    }
_exit_chunky_source_allocation_error:
    return FALSE;
}

/**
 * Free allocated chunky buffers
 */
void freeChunkyBuffer(void) {
    BYTE i = 0;

    if (ctx.srcBuffer) {
        FreeVec(ctx.srcBuffer);
        ctx.srcBuffer = NULL;
    }

    for (i = 0; i < ctx.rotationSteps; i++) {
        if (ctx.destBuffer[i]) {
            FreeVec(ctx.destBuffer[i]);
            ctx.destBuffer[i] = NULL;
        }
    }
}

void freeRotationEngine(void) {
    if (ctx.y_mult_sin) {
        FreeVec(ctx.y_mult_sin);
        ctx.y_mult_sin = NULL;
    }
    if (ctx.y_mult_cos) {
        FreeVec(ctx.y_mult_cos);
        ctx.y_mult_cos = NULL;
    }
    if (ctx.x_mult_sin) {
        FreeVec(ctx.x_mult_sin);
        ctx.x_mult_sin = NULL;
    }
    if (ctx.x_mult_cos) {
        FreeVec(ctx.x_mult_cos);
        ctx.x_mult_cos = NULL;
    }

    freeChunkyBuffer();
}

UBYTE *getSourceBuffer(void) {
    return ctx.srcBuffer;
}

UBYTE *getDestBuffer(UBYTE index) {
    return ctx.destBuffer[index];
}