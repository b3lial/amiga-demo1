// Copyright 2021 Christian Ammann
#include <stdio.h>
#include <time.h>

#include "demo1.h"

// buffers for chunky data
UBYTE *srcBuffer;
UBYTE *destBuffer[DEST_BUFFER_SIZE] = {0};

UBYTE rotationSteps = 0;
USHORT bitmapWidth = 0;
USHORT bitmapHeight = 0;

// precalculate x/y * sin/cos values
WORD *y_mult_sin = 0;
WORD *y_mult_cos = 0;
WORD *x_mult_sin = 0;
WORD *x_mult_cos = 0;

// cosinus lookup table in fix point format
// generated by lookup_cos.py
WORD cosLookup[] = {
    FLOATTOFIX(1.0),
    FLOATTOFIX(0.9848),
    FLOATTOFIX(0.9397),
    FLOATTOFIX(0.866),
    FLOATTOFIX(0.766),
    FLOATTOFIX(0.6428),
    FLOATTOFIX(0.5),
    FLOATTOFIX(0.342),
    FLOATTOFIX(0.1736),
    FLOATTOFIX(0.0),
    FLOATTOFIX(-0.1736),
    FLOATTOFIX(-0.342),
    FLOATTOFIX(-0.5),
    FLOATTOFIX(-0.6428),
    FLOATTOFIX(-0.766),
    FLOATTOFIX(-0.866),
    FLOATTOFIX(-0.9397),
    FLOATTOFIX(-0.9848),
    FLOATTOFIX(-1.0),
    FLOATTOFIX(-0.9848),
    FLOATTOFIX(-0.9397),
    FLOATTOFIX(-0.866),
    FLOATTOFIX(-0.766),
    FLOATTOFIX(-0.6428),
    FLOATTOFIX(-0.5),
    FLOATTOFIX(-0.342),
    FLOATTOFIX(-0.1736),
    FLOATTOFIX(-0.0),
    FLOATTOFIX(0.1736),
    FLOATTOFIX(0.342),
    FLOATTOFIX(0.5),
    FLOATTOFIX(0.6428),
    FLOATTOFIX(0.766),
    FLOATTOFIX(0.866),
    FLOATTOFIX(0.9397),
    FLOATTOFIX(0.9848)};

// sinus lookup table in fix point format
// generated by lookup_sin.py
WORD sinLookup[] = {
    FLOATTOFIX(0.0),
    FLOATTOFIX(0.1736),
    FLOATTOFIX(0.342),
    FLOATTOFIX(0.5),
    FLOATTOFIX(0.6428),
    FLOATTOFIX(0.766),
    FLOATTOFIX(0.866),
    FLOATTOFIX(0.9397),
    FLOATTOFIX(0.9848),
    FLOATTOFIX(1.0),
    FLOATTOFIX(0.9848),
    FLOATTOFIX(0.9397),
    FLOATTOFIX(0.866),
    FLOATTOFIX(0.766),
    FLOATTOFIX(0.6428),
    FLOATTOFIX(0.5),
    FLOATTOFIX(0.342),
    FLOATTOFIX(0.1736),
    FLOATTOFIX(0.0),
    FLOATTOFIX(-0.1736),
    FLOATTOFIX(-0.342),
    FLOATTOFIX(-0.5),
    FLOATTOFIX(-0.6428),
    FLOATTOFIX(-0.766),
    FLOATTOFIX(-0.866),
    FLOATTOFIX(-0.9397),
    FLOATTOFIX(-0.9848),
    FLOATTOFIX(-1.0),
    FLOATTOFIX(-0.9848),
    FLOATTOFIX(-0.9397),
    FLOATTOFIX(-0.866),
    FLOATTOFIX(-0.766),
    FLOATTOFIX(-0.6428),
    FLOATTOFIX(-0.5),
    FLOATTOFIX(-0.342),
    FLOATTOFIX(-0.1736)};

BOOL initRotationEngine(UBYTE rs, USHORT bw, USHORT bh) {
    rotationSteps = rs;
    bitmapWidth = bw;
    bitmapHeight = bh;

    if (bitmapWidth > MAX_BITMAP_WIDTH || bitmapHeight > MAX_BITMAP_HEIGHT) {
        writeLogFS("Error: Invalid bitmap size %dx%d\n", bitmapWidth, bitmapHeight);
        writeLogFS("Maximum bitmap size is %dx%d\n", MAX_BITMAP_WIDTH, MAX_BITMAP_HEIGHT);
        return FALSE;
    }

    y_mult_sin = AllocVec(sizeof(UWORD) * MAX_BITMAP_HEIGHT, MEMF_FAST | MEMF_CLEAR);
    if (!y_mult_sin) {
        writeLog("Error: Could not allocate memory for y_mult_sin\n");
        return FALSE;
    }

    y_mult_cos = AllocVec(sizeof(UWORD) * MAX_BITMAP_HEIGHT, MEMF_FAST | MEMF_CLEAR);
    if (!y_mult_cos) {
        writeLog("Error: Could not allocate memory for y_mult_cos\n");
        return FALSE;
    }

    x_mult_sin = AllocVec(sizeof(UWORD) * MAX_BITMAP_WIDTH, MEMF_FAST | MEMF_CLEAR);
    if (!x_mult_sin) {
        writeLog("Error: Could not allocate memory for x_mult_sin\n");
        return FALSE;
    }

    x_mult_cos = AllocVec(sizeof(UWORD) * MAX_BITMAP_WIDTH, MEMF_FAST | MEMF_CLEAR);
    if (!x_mult_cos) {
        writeLog("Error: Could not allocate memory for x_mult_cos\n");
        return FALSE;
    }

    return allocateChunkyBuffer();
}

/**
 * Rotate the element in source buffer and store the results
 * in destination buffer array.
 */
void rotateAll() {
    USHORT angle = 0;
    UBYTE i = 0;

    for (i = 0; i < rotationSteps; i++) {
        rotate(destBuffer[i], angle);
        angle += (360 / rotationSteps);  // 360 degrees / number of steps == rotation degree
    }
    return;
}

/**
 * Gets a source chunky buffer, rotates it by degree value
 * in RotationData and writes the result into destination
 * chunky buffer. Rotation is performed via matrix multiplcation
 * in fix point format.
 */
void rotate(UBYTE *dest, USHORT angle) {
    UWORD x, y = 0;
    UWORD src_index, dest_index = 0;
    WORD src_x, src_y = 0;
    WORD halfBitmapHeight, halfBitmapWidth = 0;
    UWORD lookupIndex;
    clock_t start_time;
    clock_t end_time;
    clock_t elapsed_time;

    // in this case, we can simply perform a copy
    if (angle == 360 || angle == 0) {
        CopyMem(srcBuffer, dest, bitmapWidth * bitmapHeight);
        return;
    }

    // negate angle because we have to rotate in the opposite direction
    lookupIndex = (360 - angle) / DEGREE_RESOLUTION;

    // precalculate expensive stuff
    halfBitmapHeight = bitmapHeight / 2;
    halfBitmapWidth = bitmapWidth / 2;
    start_time = clock();
    preCalcSinCos(lookupIndex, x_mult_sin, x_mult_cos,
                  y_mult_sin, y_mult_cos, halfBitmapWidth, halfBitmapHeight);
    end_time = clock();
    elapsed_time = end_time - start_time;
    printf("Runtime of preCalcSinCos(): %ld clocks\n", elapsed_time);

    // iterate over destination array
    for (y = 0; y < bitmapHeight; y++) {
        for (x = 0; x < bitmapWidth; x++) {
            // calculate src x/y coordinates
            src_x = FIXTOINT(x_mult_cos[x] - y_mult_sin[y]);
            src_y = -FIXTOINT(x_mult_sin[x] + y_mult_cos[y]);

            // convert coordinates back to array indexes
            // so we can move the rotated pixel to its new position
            dest_index = x + y * bitmapWidth;
            src_index = (src_x + halfBitmapWidth) +
                        ((src_y + halfBitmapHeight) * bitmapWidth);

            // verify x outofbounds
            if (src_x < -halfBitmapWidth || src_x >= halfBitmapWidth) {
                continue;
            }
            // verify y outofbounds
            if (src_y <= -halfBitmapHeight || (src_y > halfBitmapHeight)) {
                continue;
            }
            dest[dest_index] = srcBuffer[src_index];
        }
    }
}

/**
 * Pre-calculate sin/cos values for x/y coordinates
 * because this math is expensive
 */
void preCalcSinCos(UWORD lookupIndex, WORD *sinLookupX, WORD *cosLookupX,
                   WORD *sinLookupY, WORD *cosLookupY,
                   UWORD halfBitmapWidth, UWORD halfBitmapHeight) {
    UWORD x, y = 0;
    WORD dest_x, dest_y = 0;

    for (y = 0; y < bitmapHeight; y++) {
        dest_y = INTTOFIX(halfBitmapHeight - y);
        sinLookupY[y] = FIXMULT(dest_y, sinLookup[lookupIndex]);
        cosLookupY[y] = FIXMULT(dest_y, cosLookup[lookupIndex]);

        for (x = 0; x < bitmapWidth; x++) {
            dest_x = INTTOFIX(x - halfBitmapWidth);
            sinLookupX[x] = FIXMULT(dest_x, sinLookup[lookupIndex]);
            cosLookupX[x] = FIXMULT(dest_x, cosLookup[lookupIndex]);
        }
    }
    return;
}

/**
 * Allocate:
 * - source chunky buffer: contains the object we want to rotate
 * - destination chunky buffer array: contain the rotated objects
 */
BOOL allocateChunkyBuffer(void) {
    BYTE i = 0;

    if (rotationSteps == 0 || rotationSteps > DEST_BUFFER_SIZE) {
        printf("Error: Invalid destination buffer size %d\n", rotationSteps);
        goto _exit_chunky_source_allocation_error;
    }

    // allocate memory for chunky buffer
    srcBuffer = AllocVec(bitmapWidth * bitmapHeight, MEMF_FAST | MEMF_CLEAR);
    if (!srcBuffer) {
        printf("Error: Could not allocate memory for source chunky buffer\n");
        goto _exit_chunky_source_allocation_error;
    }

    for (i = 0; i < rotationSteps; i++) {
        destBuffer[i] = AllocVec(bitmapWidth * bitmapHeight, MEMF_FAST | MEMF_CLEAR);
        if (!(destBuffer[i])) {
            printf("Error: Could not allocate memory for destination chunky buffer array\n");
            goto _exit_chunky_source_allocation_rollback;
        }
    }

    return TRUE;

_exit_chunky_source_allocation_rollback:
    for (i -= 1; i >= 0; i--) {
        FreeVec(destBuffer[i]);
    }
_exit_chunky_source_allocation_error:
    return FALSE;
}

/**
 * Free allocated chunky buffers
 */
void freeChunkyBuffer(void) {
    BYTE i = 0;

    if (srcBuffer) {
        FreeVec(srcBuffer);
        srcBuffer = NULL;
    }

    for (i = 0; i < rotationSteps; i++) {
        if (destBuffer[i]) {
            FreeVec(destBuffer[i]);
            destBuffer[i] = NULL;
        }
    }
}

void freeRotationEngine(void) {
    if (y_mult_sin) {
        FreeVec(y_mult_sin);
        y_mult_sin = NULL;
    }
    if (y_mult_cos) {
        FreeVec(y_mult_cos);
        y_mult_cos = NULL;
    }
    if (x_mult_sin) {
        FreeVec(x_mult_sin);
        x_mult_sin = NULL;
    }
    if (x_mult_cos) {
        FreeVec(x_mult_cos);
        x_mult_cos = NULL;
    }

    freeChunkyBuffer();
}

UBYTE *getSourceBuffer(void) {
    return srcBuffer;
}

UBYTE *getDestBuffer(UBYTE index) {
    return destBuffer[index];
}